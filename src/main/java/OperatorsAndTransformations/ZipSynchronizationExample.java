package OperatorsAndTransformations;

import org.omg.PortableInterceptor.SYSTEM_EXCEPTION;
import rx.Observable;

import java.util.concurrent.TimeUnit;

import static java.util.concurrent.TimeUnit.MILLISECONDS;

public class ZipSynchronizationExample {

    public static void main(String[] args) throws InterruptedException{


        //When the sources are synchronized the observed difference between timestamps is about 20 ms
        /*Observable<Long> red = Observable.interval(10, TimeUnit.MILLISECONDS);
        Observable<Long> green = Observable.interval(10, TimeUnit.MILLISECONDS);
        Observable.zip(
            red.timestamp(),
            green.timestamp(),
            (r, g) -> r.getTimestampMillis() - g.getTimestampMillis()
        ).subscribe(System.out::println);*/


        //when the sources are not synchronized the time difference increases over time until we get a
        //rx.exceptions.MissingBackpressureException
       /* Observable<Long> yellow=Observable.interval(11,TimeUnit.MILLISECONDS);
        Observable<Long> blue=Observable.interval(10,TimeUnit.MILLISECONDS);
        Observable.zip(
            yellow.timestamp(),
            blue.timestamp(),
            (y,b)->y.getTimestampMillis()-b.getTimestampMillis()
        ).subscribe(System.out::println);*/


        //combineLatest allows us to avoid the exception at the cost of repeating emission from the fast stream:
     /*   Observable.combineLatest(
            Observable.interval(17, MILLISECONDS).map(x -> "S" + x),
            Observable.interval(10, MILLISECONDS).map(x -> "F" + x),
            (s, f) -> f + ":" + s
        ).forEach(System.out::println);*/

        //we can choose to emit only when a specific observable emits, but the other observable must have had emitted a value at least once
        /*Observable<String> fast = Observable.interval(10, MILLISECONDS).map(x -> "F" + x);
        Observable<String> slow = Observable.interval(17, MILLISECONDS).map(x -> "S" + x);
        slow
            .withLatestFrom(fast, (s, f) -> s + ":" + f)
            .forEach(System.out::println);*/

        //We can prepend a value to the auxiliary stream in order not to lose emissions from the primary stream, which in this case is S
     /*   Observable<String> fast = Observable.interval(10, MILLISECONDS)
            .map(x -> "F" + x)
            .delay(100, MILLISECONDS)
            .startWith("FX");
        Observable<String> slow = Observable.interval(17, MILLISECONDS).map(x -> "S" + x);
        slow
            .withLatestFrom(fast, (s, f) -> s + ":" + f)
            .forEach(System.out::println);

*/
        //when considering two streams we can choose to emit only the values generated by the first one that emits something
        Observable.amb(
            stream(300,10,"S"),
            stream(200,10,"F")
        ).subscribe(System.out::println);


        Thread.sleep(20000);



    }


    static Observable<String> stream(int initialDelay, int interval, String name) {
        return Observable
            .interval(initialDelay, interval, MILLISECONDS)
            .map(x -> name + x)
            .doOnSubscribe(() ->
                System.out.println("Subscribe to " + name))
            .doOnUnsubscribe(() ->
                System.out.println("Unsubscribe from " + name));
    }


}
